import requests
import pandas as pd
import geopandas as gpd
import os
from geofence import getZips,getOSMWeights
from download_shapeData import SHAPES_PATH

def ZBPCall(zipcodeList=None,NAICS_lvl=None,query=None,base_url = 'https://api.census.gov/data/2017/zbp',quietly=True):
	'''
	Wrapper to call the census API to get data from the Zip Code Business Patterns.
	Documentation found in:
	https://www.census.gov/data/developers/data-sets/cbp-nonemp-zbp/zbp-api.2017.html

	Parameters
	----------
	zipcodeList : list
		List of zipcodes. Each zip needs to be a 5-digit code string.
		If not provided it will retrieve all zip codes (may be slow)
	NAICS_lvl : int
		NAICS level at which to filter. If not provided it will not get the data by NAICS.
		If zero is provided, it will return the unfiltered table.
	query : dict (optional)
		If provided, it will override the query generated by the given parameters.
	'''
	if NAICS_lvl is not None:
		if NAICS_lvl not in range(2,7):
			raise NameError('NAICS level not supported')
	if query is None:
		query = {'get':'ESTAB,EMP,GEO_ID'}
		if NAICS_lvl is None:
			query['NAICS2017'] = '00'
		else:
			query['NAICS2017'] = '*'
		if zipcodeList is None:
			query['for'] = 'zipcode:*'
		else:
			query['for'] = 'zipcode:{}'.format(','.join(zipcodeList))
	else:
		NAICS_lvl = None

	if not quietly:
		print(query)
	r = requests.get(base_url,params=query)
	df = pd.DataFrame(r.json()[1:],columns=r.json()[0])
	if NAICS_lvl is not None:
		if NAICS_lvl!=0:
			df = df[df['NAICS2017'].astype(str).str.len()==NAICS_lvl]
	df['EMP'] = df['EMP'].astype(float)
	df['ESTAB'] = df['ESTAB'].astype(float)
	return df


def ACSCall(varNames,level='tract',groupName=None,year=2018,base_url = 'https://api.census.gov/data/{}/acs/acs5',extension='',quietly=True,someStates=False):
	'''
	Calls American Commnuity Survey API:
	https://api.census.gov/data/2018/acs/acs5.html

	Parameters
	----------
	varNames : list
		List of variables to request. Population, for example: B01003_001E
	level : str (default='tract')
		Geographic level to use. Options are: state, county, county subdivision, tract, block group, county subdivision, metropolitan statistical area/micropolitan statistical area
		For a full list see: https://api.census.gov/data/2018/acs/acs5/geography.html
	groupName : str (optional)
		Overrides varNames. Group to get data from. See options here:
		https://api.census.gov/data/2018/acs/acs5/groups.html
		For example, for population use B01003
	year : int (default=2018)
		Yer to get data for. Not all years are available. See documentation at:
		https://api.census.gov/data.html
	base_url : str (optional)
		Base url of api. 
	extension : str (optional)
		ACS API has three available API extensions: cprofile, profile, and subject.
		Variables that start with 'S' are usually found in the subject API.
	quietly : boolean (default=True)
		If false it will print progress. Used for debugging.

	Returns
	-------
	out : pandas.DataFrame
		Table with results
	'''
	year = str(year)
	base_url = base_url.format(year)
	if level in ['county','tract','block group']:
		query = {'get':'B01003_001E','for':'state:*','key':CENSUS_API_KEY}
		r = requests.get(base_url,params=query)
		qprint(r.url,quietly)
		qprint(r.status_code,quietly)
		states = set(pd.DataFrame(r.json()[1:],columns=r.json()[0])['state'])
	else:
		states = []

	base_url = base_url+'/'+extension

	if len(states)!=0:
		out = []
		for s in states:
			qprint(s,quietly)
			if groupName is None:
				query = {'get':','.join(varNames),'for':'{}:*'.format(level),'in':'state:{}'.format(s),'key':CENSUS_API_KEY}
			else:
				query = {'get':'group({})'.format(groupName),'for':'{}:*'.format(level),'in':'state:{}'.format(s),'key':CENSUS_API_KEY}
			r = requests.get(base_url,params=query)
			qprint(r.url,quietly)
			qprint(r.status_code,quietly)
			df = pd.DataFrame(r.json()[1:],columns=r.json()[0])
			out.append(df)
		out = pd.concat(out,sort=True)
	else:
		if groupName is None:
			query = {'get':','.join(varNames),'for':'{}:*'.format(level),'key':CENSUS_API_KEY}
		else:
			query = {'get':'group({})'.format(groupName),'for':'{}:*'.format(level),'key':CENSUS_API_KEY}
		r = requests.get(base_url,params=query)
		qprint(r.url,quietly)
		qprint(r.status_code,quietly)
		out = pd.DataFrame(r.json()[1:],columns=r.json()[0])
	for c in out.columns: 
		if (c[0]=='B')|(c[0]=='S'):
			try:
				out[c] = out[c].astype(float)
			except:
				pass
			out.loc[out[c]==-888888888,c] = np.nan
	if level=='tract':
		out['Census Tract Number'] = out['state']+out['county']+out['tract']
	return out

def main():
	'''
	Usage example
	'''
	bounds = gpd.read_file(os.path.join(SHAPES_PATH,'bounds','Kendall_bounds.shp')).to_crs({'init':"EPSG:4326"})['geometry'].values[0]

	zipcodeList = getZips(bounds=bounds,quietly=False)
	df = ZBPCall(zipcodeList=zipcodeList,quietly=False)
	print(df)

	zipShapes = getZips(bounds=bounds,asList=False)
	weights = getOSMWeights(bounds,zipShapes,'ZCTA5CE10',quietly=False)

	weighted = pd.merge(df,weights.rename(columns={'ZCTA5CE10':'zip code'}))
	weighted['weighted_EMP']   = weighted['EMP']*weighted['weight']
	weighted['weighted_ESTAB'] = weighted['ESTAB']*weighted['weight']
	print(weighted[['weighted_EMP','weighted_ESTAB']].sum())

if __name__ == '__main__':
	main()